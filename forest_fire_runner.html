<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üå≤üî• Forest Fire Runner ü¶å</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        canvas {
            background: linear-gradient(to bottom, #1a1a3a 0%, #2d1b4e 40%, #4a2c2a 100%);
            border: 2px solid #333;
            image-rendering: pixelated;
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.3);
        }
        
        .ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .health-bar-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 8px;
            border: 2px solid #333;
        }
        
        .health-bar {
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid #666;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000 0%, #ff4500 25%, #ffa500 50%, #32cd32 75%, #00ff00 100%);
            transition: width 0.3s ease;
            width: 100%;
        }
        
        .health-text {
            color: white;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
            font-family: 'Courier New', monospace;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .damage-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000;
            font-size: 24px;
            font-weight: bold;
            z-index: 15;
            pointer-events: none;
            opacity: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .damage-flash {
            animation: damageFlash 0.5s ease-out;
        }
        
        @keyframes damageFlash {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }
        
        .low-health-warning {
            animation: lowHealthPulse 1s infinite;
        }
        
        @keyframes lowHealthPulse {
            0%, 100% { box-shadow: 0 0 0 rgba(255, 0, 0, 0.4); }
            50% { box-shadow: 0 0 20px rgba(255, 0, 0, 0.8); }
        }
        
        .fire-warning {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #ff4444;
            font-size: 18px;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff4444;
            text-align: center;
            font-size: 24px;
            display: none;
            z-index: 20;
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border: 3px solid #ff4444;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
        }
        
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            font-size: 14px;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            font-size: 20px;
            z-index: 20;
            background: rgba(0,0,0,0.8);
            padding: 40px;
            border: 2px solid #4CAF50;
            border-radius: 10px;
        }
        
        .heartbeat {
            animation: heartbeat 0.5s infinite;
        }
        
        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    
    <div class="start-screen" id="startScreen">
        <h1>üå≤üî• FOREST FIRE RUNNER ü¶å</h1>
        <p>A wildfire is spreading! Help the deer escape!</p>
        <br>
        <p>üéÆ <strong>Controls:</strong></p>
        <p>SPACE or CLICK to JUMP</p>
        <br>
        <p>‚ö†Ô∏è <strong>Survival Tips:</strong></p>
        <p>‚Ä¢ Avoid fallen trees, fire pits, and deep holes</p>
        <p>‚Ä¢ Hit an obstacle = slower speed + fire gets closer</p>
        <p>‚Ä¢ Hit 2 obstacles quickly = GAME OVER!</p>
        <p>‚Ä¢ Stay obstacle-free to recover speed</p>
        <br>
        <p><strong>Press SPACE to start your escape!</strong></p>
    </div>
    
    <div class="ui">
        <div>üèÉ Distance: <span id="distance">0</span>m</div>
        <div>üèÜ High Score: <span id="highScore">0</span>m</div>
        <div>‚ö° Speed: <span id="speed">1.0</span>x</div>
        <div>‚ù§Ô∏è Status: <span id="status">Safe</span></div>
    </div>
    
    <div class="health-bar-container" id="healthBarContainer" style="display: none;">
        <div class="health-text" id="healthText">Health: <span id="health-value">100</span>/100</div>
        <div class="health-bar" id="healthBar">
            <div class="health-fill" id="health-fill" style="width: 100%;"></div>
        </div>
    </div>
    
    <div class="damage-indicator" id="damageIndicator">-10</div>
    
    <div class="fire-warning" id="fireWarning" style="display: none;">
        üî• FIRE APPROACHING! üî•
    </div>
    
    <div class="game-over" id="gameOver">
        <h2 id="gameOverTitle">üî• CAUGHT BY THE WILDFIRE! üî•</h2>
        <p id="gameOverMessage">The forest fire has consumed everything...</p>
        <br>
        <p>Distance Traveled: <span id="finalDistance">0</span>m</p>
        <p id="newRecord" style="color: #4CAF50; display: none;">üéâ NEW RECORD! üéâ</p>
        <br>
        <p><strong>Press SPACE to try again</strong></p>
    </div>
    
    <div class="instructions">
        <p>ü¶å Press SPACE or CLICK to JUMP ‚Ä¢ Escape the wildfire and survive! üî•</p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameRunning = false;
        let gameStarted = false;
        let gameSpeed = 2;
        let baseSpeed = 2;
        let distance = 0;
        let highScore = localStorage.getItem('forestFireHighScore') || 0;
        let lastObstacleHit = 0;
        let hitRecoveryTime = 3000; // 3 seconds to recover (reduced from 5)
        let obstacleHitCount = 0;
        let consecutiveHits = 0; // Track consecutive hits specifically
        let gameStartTime = 0;
        let health = 100; // Player health
        let maxHealth = 100; // Maximum health
        let fireDamageInterval = 1000; // Fire damage interval in ms
        let lastFireDamageTime = 0;
        
        // Enhanced Player (Deer) with better physics
        const deer = {
            x: 100,
            y: 280,
            width: 32,
            height: 32,
            jumpVelocity: 0,
            jumping: false,
            onGround: true,
            groundY: 280,
            animFrame: 0,
            // Enhanced jump physics - more responsive like T-Rex game
            maxJumpHeight: 90, // Increased for better clearance
            jumpPower: -16, // Slightly reduced for quicker response
            gravity: 0.7, // Reduced gravity for better control
            terminalVelocity: 14, // Increased for faster landings
            // New variables for better jump feel
            jumpHoldTime: 0,
            maxJumpHoldTime: 8, // Frames you can hold jump for variable height
            variableJumpEnabled: true
        };
        
        // Enhanced Fire system
        const fire = {
            x: -200,
            particles: [],
            intensity: 0.4,
            closenessLevel: 0,
            baseAdvanceSpeed: 0.3, // Base speed fire moves forward
            dangerAdvanceSpeed: 2.5, // Speed when deer is in danger
            retreatSpeed: 0.8 // Speed fire retreats when deer recovers
        };
        
        // Enhanced Obstacles system
        const obstacles = [];
        const obstacleTypes = [
            { type: 'tree', weight: 3, jumpable: true },
            { type: 'pit', weight: 2, jumpable: true },
            { type: 'fire', weight: 2, jumpable: true },
            { type: 'rock', weight: 1, jumpable: true } // New obstacle type
        ];
        let lastObstacleSpawn = 0;
        let obstacleSpawnCooldown = 1500; // Minimum time between obstacles
        
        // Background elements
        const stars = [];
        const trees = [];
        
        // Initialize stars
        for(let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * 150,
                brightness: Math.random() * 0.8 + 0.2,
                twinkle: Math.random() * 100
            });
        }
        
        // Initialize background trees
        for(let i = 0; i < 20; i++) {
            trees.push({
                x: i * 50,
                height: 60 + Math.random() * 40,
                type: Math.floor(Math.random() * 3)
            });
        }
        
        // Initialize fire particles
        for(let i = 0; i < 80; i++) {
            fire.particles.push({
                x: Math.random() * 400 - 200,
                y: 250 + Math.random() * 150,
                vx: Math.random() * 3 + 1,
                vy: Math.random() * 4 - 2,
                life: Math.random() * 100,
                maxLife: 100,
                size: Math.random() * 4 + 2
            });
        }
        
        // Audio context for sound effects
        let audioContext;
        
        function initAudio() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
        }
        
        function playSound(frequency, duration, type = 'sine', volume = 0.1) {
            if (!audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                // Audio failed, continue silently
            }
        }
        
        function drawPixelRect(x, y, width, height, color) {
            ctx.fillStyle = color;
            ctx.fillRect(Math.floor(x), Math.floor(y), width, height);
        }
        
        function drawDeer() {
            const x = Math.floor(deer.x);
            const y = Math.floor(deer.y);
            
            // Enhanced animation frame for running (faster when jumping)
            const animSpeed = deer.jumping ? 0.5 : 0.3;
            deer.animFrame = (deer.animFrame + animSpeed) % 4;
            const legOffset = Math.floor(deer.animFrame) < 2 ? 0 : 2;
            
            // Body (brown) - slightly compressed when jumping
            const bodyHeight = deer.jumping ? 10 : 12;
            drawPixelRect(x + 8, y + 16 + (12 - bodyHeight), 16, bodyHeight, '#8B4513');
            
            // Head
            drawPixelRect(x + 20, y + 8, 12, 12, '#A0522D');
            
            // Legs with enhanced running animation
            if (deer.jumping) {
                // Tucked legs when jumping
                drawPixelRect(x + 10, y + 26, 3, 3, '#654321');
                drawPixelRect(x + 18, y + 24, 3, 3, '#654321');
                drawPixelRect(x + 22, y + 24, 3, 3, '#654321');
                drawPixelRect(x + 26, y + 26, 3, 3, '#654321');
            } else {
                // Normal running legs
                drawPixelRect(x + 8, y + 28 + legOffset, 4, 4 - legOffset, '#654321');
                drawPixelRect(x + 16, y + 28 - legOffset, 4, 4 + legOffset, '#654321');
                drawPixelRect(x + 20, y + 28 - legOffset, 4, 4 + legOffset, '#654321');
                drawPixelRect(x + 28, y + 28 + legOffset, 4, 4 - legOffset, '#654321');
            }
            
            // Antlers
            drawPixelRect(x + 22, y + 2, 2, 6, '#8B4513');
            drawPixelRect(x + 28, y + 2, 2, 6, '#8B4513');
            drawPixelRect(x + 20, y + 4, 2, 2, '#8B4513');
            drawPixelRect(x + 30, y + 4, 2, 2, '#8B4513');
            
            // Eye (white with black pupil) - expression changes based on state
            const eyeColor = consecutiveHits >= 1 ? '#FFD700' : '#FFF'; // Golden when in danger
            drawPixelRect(x + 26, y + 12, 3, 2, eyeColor);
            drawPixelRect(x + 27, y + 12, 1, 2, '#000');
            
            // Nose
            drawPixelRect(x + 30, y + 16, 2, 1, '#000');
            
            // Tail
            drawPixelRect(x + 4, y + 18, 4, 2, '#8B4513');
        }
        
        function drawObstacle(obstacle) {
            const x = Math.floor(obstacle.x);
            const y = Math.floor(obstacle.y);
            
            if (obstacle.type === 'tree') {
                // Fallen tree trunk
                drawPixelRect(x, y, 40, 16, '#4A4A4A');
                drawPixelRect(x + 4, y + 4, 32, 8, '#654321');
                // Tree rings
                for(let i = 0; i < 3; i++) {
                    drawPixelRect(x + 8 + i * 8, y + 6, 2, 4, '#8B4513');
                }
                // Branches
                drawPixelRect(x + 35, y - 4, 8, 4, '#654321');
                drawPixelRect(x + 40, y - 8, 6, 4, '#228B22');
            } else if (obstacle.type === 'pit') {
                // Deep hole with jagged edges
                drawPixelRect(x, y, 32, 32, '#000');
                drawPixelRect(x + 4, y + 4, 24, 24, '#1a1a1a');
                drawPixelRect(x + 8, y + 8, 16, 16, '#333');
                // Jagged top
                for(let i = 0; i < 4; i++) {
                    drawPixelRect(x + i * 8, y - 2, 4, 2, '#2d4a2d');
                }
            } else if (obstacle.type === 'fire') {
                // Fire pit with stones
                drawPixelRect(x, y + 16, 24, 16, '#4A4A4A');
                drawPixelRect(x + 4, y + 20, 16, 8, '#696969');
                
                // Animated fire effect
                for(let i = 0; i < 12; i++) {
                    const fx = x + 4 + Math.random() * 16;
                    const fy = y + Math.random() * 20;
                    const flameHeight = 6 + Math.random() * 8;
                    const colors = ['#FF0000', '#FF4500', '#FFD700', '#FF8C00'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    drawPixelRect(fx, fy, 2, flameHeight, color);
                }
                
                // Smoke
                for(let i = 0; i < 5; i++) {
                    const sx = x + 8 + Math.random() * 8;
                    const sy = y - 10 + Math.random() * 10;
                    ctx.globalAlpha = 0.3;
                    drawPixelRect(sx, sy, 2, 4, '#666');
                    ctx.globalAlpha = 1;
                }
            } else if (obstacle.type === 'rock') {
                // Large rock
                drawPixelRect(x, y, 24, 20, '#696969');
                drawPixelRect(x + 4, y + 4, 16, 12, '#808080');
                // Rock details
                drawPixelRect(x + 8, y + 8, 8, 4, '#A9A9A9');
                drawPixelRect(x + 2, y + 16, 4, 4, '#555');
                drawPixelRect(x + 18, y + 14, 4, 6, '#555');
            }
        }
        
        function drawFire() {
            // Update and draw fire particles
            fire.particles.forEach(particle => {
                particle.x += particle.vx + gameSpeed * 0.5;
                particle.y += particle.vy;
                particle.vy += Math.random() * 0.2 - 0.1; // Flickering
                particle.life--;
                
                if (particle.life <= 0 || particle.x > canvas.width + 100) {
                    particle.x = fire.x + Math.random() * 150;
                    particle.y = 200 + Math.random() * 200;
                    particle.life = particle.maxLife;
                    particle.vx = Math.random() * 3 + 1;
                    particle.vy = Math.random() * 4 - 2;
                }
                
                const alpha = (particle.life / particle.maxLife) * fire.intensity;
                const colors = ['#FF0000', '#FF4500', '#FFD700', '#FF8C00', '#DC143C'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                ctx.globalAlpha = alpha;
                drawPixelRect(particle.x, particle.y, particle.size, particle.size, color);
                ctx.globalAlpha = 1;
            });
            
            // Fire wall approaching effect
            const fireGradient = ctx.createLinearGradient(fire.x, 0, fire.x + 300, 0);
            fireGradient.addColorStop(0, `rgba(255, 69, 0, ${fire.intensity * 0.8})`);
            fireGradient.addColorStop(0.5, `rgba(255, 140, 0, ${fire.intensity * 0.4})`);
            fireGradient.addColorStop(1, 'rgba(255, 69, 0, 0)');
            
            ctx.fillStyle = fireGradient;
            ctx.fillRect(fire.x, 150, 300, 250);
            
            // Heat wave effect
            if (fire.x > -100) {
                for(let i = 0; i < 20; i++) {
                    const waveX = fire.x + 200 + Math.random() * 100;
                    const waveY = 200 + Math.random() * 200;
                    ctx.globalAlpha = 0.1;
                    drawPixelRect(waveX, waveY, 2, 6, '#FFD700');
                    ctx.globalAlpha = 1;
                }
            }
        }
        
        function drawBackground() {
            // Night sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, 200);
            skyGradient.addColorStop(0, '#0a0a2e');
            skyGradient.addColorStop(1, '#16213e');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, 200);
            
            // Twinkling stars
            stars.forEach(star => {
                star.x -= gameSpeed * 0.1;
                star.twinkle += 0.1;
                if (star.x < -5) star.x = canvas.width + 5;
                
                const twinkleAlpha = (Math.sin(star.twinkle) + 1) * 0.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness * twinkleAlpha})`;
                ctx.fillRect(Math.floor(star.x), Math.floor(star.y), 2, 2);
            });
            
            // Moon
            ctx.fillStyle = '#F5F5DC';
            ctx.beginPath();
            ctx.arc(canvas.width - 80, 60, 20, 0, Math.PI * 2);
            ctx.fill();
            
            // Ground with texture
            const groundGradient = ctx.createLinearGradient(0, 320, 0, 400);
            groundGradient.addColorStop(0, '#2d4a2d');
            groundGradient.addColorStop(1, '#1a2e1a');
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, 320, canvas.width, 80);
            
            // Ground details (grass, rocks)
            for(let i = 0; i < canvas.width; i += 20) {
                const grassX = i - (gameSpeed * 3) % 20;
                // Grass
                drawPixelRect(grassX, 318, 2, 4, '#228B22');
                drawPixelRect(grassX + 5, 316, 2, 6, '#32CD32');
                // Small rocks
                if (Math.random() > 0.8) {
                    drawPixelRect(grassX + 10, 330, 4, 3, '#696969');
                }
            }
            
            // Background forest silhouette with parallax
            trees.forEach(tree => {
                tree.x -= gameSpeed * 0.3;
                if (tree.x < -60) tree.x = canvas.width + 20;
                
                const treeX = Math.floor(tree.x);
                const treeHeight = tree.height;
                
                // Tree trunk
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(treeX, 200, 8, treeHeight);
                
                // Tree crown
                ctx.fillStyle = '#0d4d0d';
                for(let i = 0; i < 3; i++) {
                    const crownY = 190 - i * 15;
                    const crownWidth = 30 - i * 5;
                    ctx.fillRect(treeX - crownWidth/2 + 4, crownY, crownWidth, 20);
                }
                
                // Tree details based on type
                if (tree.type === 1) {
                    // Pine tree
                    for(let i = 0; i < 4; i++) {
                        const branchY = 200 + i * 10;
                        const branchWidth = 20 - i * 3;
                        ctx.fillRect(treeX - branchWidth/2 + 4, branchY, branchWidth, 6);
                    }
                } else if (tree.type === 2) {
                    // Leafy tree
                    ctx.fillStyle = '#228B22';
                    ctx.fillRect(treeX - 15, 180, 30, 25);
                }
            });
        }
        
        function getWeightedObstacleType() {
            const totalWeight = obstacleTypes.reduce((sum, type) => sum + type.weight, 0);
            let random = Math.random() * totalWeight;
            
            for (const obstacleType of obstacleTypes) {
                random -= obstacleType.weight;
                if (random <= 0) {
                    return obstacleType.type;
                }
            }
            return obstacleTypes[0].type; // Fallback
        }
        
        function spawnObstacle() {
            const currentTime = Date.now();
            
            // Check if enough time has passed and there's enough space
            if (currentTime - lastObstacleSpawn < obstacleSpawnCooldown) {
                return;
            }
            
            const lastObstacle = obstacles[obstacles.length - 1];
            const minDistance = 180 + Math.random() * 120; // Variable spacing: 180-300px
            
            if (obstacles.length === 0 || lastObstacle.x < canvas.width - minDistance) {
                const type = getWeightedObstacleType();
                
                // Adjust obstacle properties based on type
                let obstacleY, obstacleWidth, obstacleHeight;
                
                switch(type) {
                    case 'tree':
                        obstacleY = 296;
                        obstacleWidth = 40;
                        obstacleHeight = 16;
                        break;
                    case 'pit':
                        obstacleY = 288;
                        obstacleWidth = 32;
                        obstacleHeight = 32;
                        break;
                    case 'fire':
                        obstacleY = 296;
                        obstacleWidth = 24;
                        obstacleHeight = 16;
                        break;
                    case 'rock':
                        obstacleY = 292;
                        obstacleWidth = 24;
                        obstacleHeight = 20;
                        break;
                    default:
                        obstacleY = 296;
                        obstacleWidth = 32;
                        obstacleHeight = 16;
                }
                
                const obstacle = {
                    x: canvas.width + 50,
                    y: obstacleY,
                    type: type,
                    width: obstacleWidth,
                    height: obstacleHeight,
                    jumpable: true
                };
                
                obstacles.push(obstacle);
                lastObstacleSpawn = currentTime;
                
                // Decrease spawn cooldown as game progresses (but keep minimum)
                obstacleSpawnCooldown = Math.max(800, 1500 - Math.floor(distance / 50) * 50);
            }
        }
        
        function updateGame() {
            if (!gameRunning) return;
            
            // Update distance
            distance += gameSpeed * 0.1;
            
            // Progressive speed increase - more gradual and realistic
            const timeElapsed = (Date.now() - gameStartTime) / 1000; // seconds
            const distanceSpeedBonus = Math.floor(distance / 300) * 0.2; // Every 300m
            const timeSpeedBonus = Math.floor(timeElapsed / 30) * 0.1; // Every 30 seconds
            baseSpeed = 2 + distanceSpeedBonus + timeSpeedBonus;
            
            // Enhanced fire mechanics - ONLY advance after hitting obstacles
            const timeSinceHit = Date.now() - lastObstacleHit;
            const currentTime = Date.now();
            
            if (consecutiveHits >= 1 && timeSinceHit < hitRecoveryTime) {
                // Deer is in danger after hitting obstacle(s)
                gameSpeed = Math.max(1.2, baseSpeed * 0.6);
                fire.intensity = Math.min(1.0, 0.5 + (hitRecoveryTime - timeSinceHit) / hitRecoveryTime * 0.5);
                
                // Fire advances faster based on consecutive hits
                const advanceMultiplier = consecutiveHits >= 2 ? 3 : 1.5;
                fire.x = Math.min(deer.x - 40, fire.x + fire.dangerAdvanceSpeed * advanceMultiplier);
                fire.closenessLevel = Math.min(3, Math.floor((hitRecoveryTime - timeSinceHit) / 1000));
                
                // Fire damage system - damage health when fire gets close
                const fireDistance = deer.x - fire.x;
                if (fireDistance < 150 && currentTime - lastFireDamageTime > fireDamageInterval) {
                    // Calculate damage based on fire proximity
                    let damage = 5; // Base damage
                    if (fireDistance < 100) damage = 8; // Closer = more damage
                    if (fireDistance < 60) damage = 12; // Very close = high damage
                    if (consecutiveHits >= 2) damage *= 1.5; // Critical state = extra damage
                    
                    health = Math.max(0, health - damage);
                    lastFireDamageTime = currentTime;
                    updateHealthDisplay();
                    
                    // Play fire damage sound
                    playSound(200 + Math.random() * 100, 0.2, 'sawtooth', 0.1);
                    
                    // Check if health depleted
                    if (health <= 0) {
                        gameOver();
                        return;
                    }
                }
                
                // Show fire warning
                document.getElementById('fireWarning').style.display = 'block';
                document.getElementById('status').textContent = consecutiveHits >= 2 ? 'CRITICAL!' : 'DANGER!';
                document.getElementById('status').style.color = consecutiveHits >= 2 ? '#ff0000' : '#ff4444';
                
                // Heartbeat effect when fire is very close
                if (fire.closenessLevel >= 2 || consecutiveHits >= 2) {
                    document.body.classList.add('heartbeat');
                    // Play heartbeat sound
                    if (Math.random() > 0.85) {
                        playSound(80, 0.1, 'sine', 0.05);
                    }
                } else {
                    document.body.classList.remove('heartbeat');
                }
            } else {
                // Deer has recovered or never hit anything
                gameSpeed = baseSpeed + Math.floor(distance / 150) * 0.15; // Smoother speed progression
                fire.intensity = Math.max(0.3, fire.intensity - 0.015);
                
                // Fire only retreats if deer has been safe for a while
                if (timeSinceHit > hitRecoveryTime) {
                    fire.x = Math.max(-200, fire.x - fire.retreatSpeed);
                    consecutiveHits = 0; // Reset consecutive hits
                } else {
                    // Fire stays in place during recovery period
                    fire.x = Math.max(-200, fire.x - fire.baseAdvanceSpeed);
                }
                
                fire.closenessLevel = 0;
                
                // Hide fire warning
                document.getElementById('fireWarning').style.display = 'none';
                document.getElementById('status').textContent = 'Safe';
                document.getElementById('status').style.color = '#4CAF50';
                document.body.classList.remove('heartbeat');
            }
            
            // Enhanced deer physics
            updateJumpPhysics();
            
            // Spawn obstacles
            spawnObstacle();
            
            // Update obstacles
            for(let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.x -= gameSpeed;
                
                // Enhanced collision detection with more precise hitboxes
                const deerLeft = deer.x + 4;
                const deerRight = deer.x + deer.width - 4;
                const deerTop = deer.y + 2;
                const deerBottom = deer.y + deer.height - 2;
                
                const obstacleLeft = obstacle.x;
                const obstacleRight = obstacle.x + obstacle.width;
                const obstacleTop = obstacle.y;
                const obstacleBottom = obstacle.y + obstacle.height;
                
                if (deerRight > obstacleLeft && 
                    deerLeft < obstacleRight &&
                    deerBottom > obstacleTop &&
                    deerTop < obstacleBottom) {
                    
                    handleObstacleHit();
                    obstacles.splice(i, 1); // Remove the obstacle that was hit
                    continue;
                }
                
                // Remove off-screen obstacles
                if (obstacle.x + obstacle.width < 0) {
                    obstacles.splice(i, 1);
                }
            }
            
            // Check if fire caught the deer (only after 2 hits)
            if (consecutiveHits >= 2 && fire.x > deer.x - 40) {
                gameOver();
            }
            
            // Update UI
            document.getElementById('distance').textContent = Math.floor(distance);
            document.getElementById('speed').textContent = (gameSpeed / 2).toFixed(1);
        }
        
        function handleObstacleHit() {
            playSound(150, 0.3, 'sawtooth', 0.15);
            
            const timeSinceLastHit = Date.now() - lastObstacleHit;
            
            // Increment consecutive hits if within recovery time
            if (timeSinceLastHit < hitRecoveryTime) {
                consecutiveHits++;
            } else {
                consecutiveHits = 1; // Reset to 1 for this hit
            }
            
            // Game over only happens after 2 consecutive hits within recovery time
            if (consecutiveHits >= 2) {
                // Don't immediately end - let fire catch up for dramatic effect
                lastObstacleHit = Date.now();
                
                // Enhanced screen shake effect for critical hits
                canvas.style.transform = 'translateX(8px)';
                setTimeout(() => {
                    canvas.style.transform = 'translateX(-8px)';
                    setTimeout(() => {
                        canvas.style.transform = 'translateX(4px)';
                        setTimeout(() => {
                            canvas.style.transform = 'translateX(0)';
                        }, 50);
                    }, 50);
                }, 50);
            } else {
                lastObstacleHit = Date.now();
                
                // Normal screen shake
                canvas.style.transform = 'translateX(5px)';
                setTimeout(() => {
                    canvas.style.transform = 'translateX(-5px)';
                    setTimeout(() => {
                        canvas.style.transform = 'translateX(0)';
                    }, 50);
                }, 50);
            }
        }
        
        function gameOver() {
            gameRunning = false;
            playSound(80, 2, 'sawtooth', 0.2);
            
            let isNewRecord = false;
            if (distance > highScore) {
                highScore = Math.floor(distance);
                localStorage.setItem('forestFireHighScore', highScore);
                document.getElementById('highScore').textContent = highScore;
                isNewRecord = true;
            }
            
            document.getElementById('finalDistance').textContent = Math.floor(distance);
            document.getElementById('newRecord').style.display = isNewRecord ? 'block' : 'none';
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('fireWarning').style.display = 'none';
            document.body.classList.remove('heartbeat');
        }
        
        function startGame() {
            gameRunning = true;
            gameStarted = true;
            gameSpeed = baseSpeed;
            distance = 0;
            deer.y = deer.groundY;
            deer.jumping = false;
            deer.jumpVelocity = 0;
            deer.onGround = true;
            obstacles.length = 0;
            fire.x = -200;
            fire.intensity = 0.4;
            fire.closenessLevel = 0;
            lastObstacleHit = 0;
            obstacleHitCount = 0;
            consecutiveHits = 0;
            gameStartTime = Date.now();
            lastObstacleSpawn = 0;
            obstacleSpawnCooldown = 1500;
            health = maxHealth; // Reset health
            
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('fireWarning').style.display = 'none';
            document.getElementById('highScore').textContent = highScore;
            document.getElementById('status').textContent = 'Safe';
            document.getElementById('status').style.color = '#4CAF50';
            document.getElementById('healthBarContainer').style.display = 'block'; // Show health bar
            
            initAudio();
            playSound(400, 0.2, 'sine', 0.1); // Start game sound
        }
        
        // Enhanced jump system with variable height
        let jumpKeyPressed = false;
        let jumpKeyHoldTime = 0;
        
        function jump() {
            if (deer.onGround && gameRunning) {
                deer.jumping = true;
                deer.onGround = false;
                deer.jumpVelocity = deer.jumpPower;
                deer.jumpHoldTime = 0;
                jumpKeyPressed = true;
                jumpKeyHoldTime = 0;
                playSound(600, 0.15, 'square', 0.08);
            }
        }
        
        function updateJumpPhysics() {
            if (deer.jumping) {
                // Variable jump height based on key hold time
                if (jumpKeyPressed && deer.jumpHoldTime < deer.maxJumpHoldTime && deer.jumpVelocity < 0) {
                    // Add extra upward force while key is held (like T-Rex game)
                    deer.jumpVelocity += -0.8; // Additional lift
                    deer.jumpHoldTime++;
                }
                
                // Apply gravity
                deer.jumpVelocity += deer.gravity;
                
                // Apply terminal velocity
                if (deer.jumpVelocity > deer.terminalVelocity) {
                    deer.jumpVelocity = deer.terminalVelocity;
                }
                
                deer.y += deer.jumpVelocity;
                deer.onGround = false;
                
                // Check if deer landed
                if (deer.y >= deer.groundY) {
                    deer.y = deer.groundY;
                    deer.jumping = false;
                    deer.jumpVelocity = 0;
                    deer.onGround = true;
                    deer.jumpHoldTime = 0;
                    jumpKeyPressed = false;
                    jumpKeyHoldTime = 0;
                    playSound(200, 0.05, 'sine', 0.03); // Landing sound
                }
            } else {
                deer.onGround = true;
            }
        }
        
        function updateHealthDisplay() {
            const healthPercent = (health / maxHealth) * 100;
            const healthFill = document.getElementById('health-fill');
            const healthValue = document.getElementById('health-value');
            
            healthFill.style.width = `${healthPercent}%`;
            healthValue.textContent = Math.floor(health);
            
            // Show damage indicator text briefly
            const damageIndicator = document.getElementById('damageIndicator');
            const previousHealth = Math.floor(health + (maxHealth - health));
            const currentDamage = Math.floor(maxHealth - health);
            
            if (currentDamage > 0) {
                damageIndicator.textContent = `-${currentDamage}`;
                damageIndicator.classList.add('damage-flash');
                
                setTimeout(() => {
                    damageIndicator.classList.remove('damage-flash');
                }, 500);
            } else {
                damageIndicator.textContent = '';
            }
            
            // Low health warning
            if (health <= 30) {
                document.getElementById('healthBarContainer').classList.add('low-health-warning');
            } else {
                document.getElementById('healthBarContainer').classList.remove('low-health-warning');
            }
            
            // Change health bar color based on health level
            if (health <= 20) {
                healthFill.style.background = '#ff0000';
            } else if (health <= 50) {
                healthFill.style.background = 'linear-gradient(90deg, #ff0000 0%, #ff4500 50%, #ffa500 100%)';
            } else {
                healthFill.style.background = 'linear-gradient(90deg, #ff0000 0%, #ff4500 25%, #ffa500 50%, #32cd32 75%, #00ff00 100%)';
            }
        }
        
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawBackground();
            drawFire();
            
            obstacles.forEach(drawObstacle);
            drawDeer();
            
            updateGame();
            
            // Health regeneration when safe
            const timeNow = Date.now();
            if (consecutiveHits < 1 && health < maxHealth && timeNow - lastFireDamageTime > fireDamageInterval) {
                health = Math.min(maxHealth, health + 0.1);
                updateHealthDisplay();
            }
            
            // Add atmospheric effects
            if (gameRunning) {
                // Add some ember particles in the air
                for(let i = 0; i < 3; i++) {
                    if (Math.random() > 0.95) {
                        const emberX = canvas.width + Math.random() * 50;
                        const emberY = 200 + Math.random() * 100;
                        ctx.fillStyle = '#FF4500';
                        ctx.globalAlpha = 0.6;
                        ctx.fillRect(emberX, emberY, 2, 2);
                        ctx.globalAlpha = 1;
                    }
                }
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Enhanced event listeners for variable jump height
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameRunning) {
                    jump();
                } else {
                    startGame();
                }
            }
        });
        
        // Key release handler for variable jump height
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                jumpKeyPressed = false; // Stop adding extra lift
            }
        });
        
        // Mouse handlers for variable jump height
        canvas.addEventListener('mousedown', (e) => {
            if (gameRunning) {
                jump();
            } else {
                startGame();
            }
        });
        
        canvas.addEventListener('mouseup', (e) => {
            jumpKeyPressed = false; // Stop adding extra lift
        });
        
        // Prevent context menu on right click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        // Initialize high score display
        document.getElementById('highScore').textContent = highScore;
        
        // Start the game loop
        gameLoop();
        
        // Ambient fire crackling sound (very subtle)
        setInterval(() => {
            if (gameRunning && Math.random() > 0.95) {
                playSound(100 + Math.random() * 50, 0.1, 'sawtooth', 0.02);
            }
        }, 1000);
    </script>
</body>
</html>